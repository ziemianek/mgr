from fastapi import FastAPI, HTTPException, Query, Depends
from typing import Optional, Union, Annotated
from uuid import uuid4
from contextlib import asynccontextmanager
from .models import  CreateTask, Task
from .db import init_db, get_session, Session, select


@asynccontextmanager
async def lifespan(app: FastAPI):
    init_db()
    yield


app = FastAPI(lifespan=lifespan)


@app.get("/")
async def root() -> dict[str, str]:
    """
    Root endpoint that returns the service name.

    Returns:
        dict[str, str]: A dictionary containing the service name.
    """
    return {
        "service_name:": "tasks",
    }


@app.get(f"/tasks")
async def get_tasks(
    id: Annotated[Optional[str], Query(min_length=36, max_length=36)] = None,
    session: Session = Depends(get_session)
) -> Union[Task, list[Task]]:
    """
    Retrieve tasks from the task list.

    Args:
        id (Optional[int]): The ID of the task to retrieve. If not provided, all tasks will be returned.

    Returns:
        Union[Task, list[Task]]: A single task with the specified ID if provided, otherwise a list of all tasks.

    Raises:
        fastapi.HTTPException: If a task with the specified ID is not found, a 404 HTTP exception is raised.
    """
    if id:
        task = session.get(Task, id)
        if task is None:
            raise HTTPException(status_code=404)
        return task

    return session.exec(select(Task)).all()


@app.post("/tasks")
async def create_task(
    task_data: CreateTask,
    session: Session = Depends(get_session)
) -> Task:
    task = Task(
        task_id=str(uuid4()),  # FIXME: This should be generated by the database
        task_name=task_data.task_name,
        task_description=task_data.task_description
    )
    session.add(task)
    session.commit()
    session.refresh(task)
    return task
